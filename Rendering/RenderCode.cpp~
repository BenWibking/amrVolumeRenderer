#include "RenderCode.h"
#include <math.h>
#include <stdlib.h>

void calcPlane(double* D, double* R, double* C, double* B,
			Vertex* v1, Vertex* v2, Vertex* v3) {
	
	double v12[3] = {v2->p1 - v1->p1,
				  v2->p2 - v1->p2,
				  v2->p3 - v1->p3};
	double v13[3] = {v3->p1 - v1->p1,
				  v3->p2 - v1->p2,
				  v3->p3 - v1->p3};
  	
  	*D =       v12[1] * v13[2] - v13[1] * v12[2];
  	*R = -1 * (v12[0] * v13[2] - v13[0] * v12[2]);
  	*C =       v12[0] * v13[1] - v13[0] * v12[1];
  	
  	*B = *D * v2->p1 + *R * v2->p2 + *C * v2->p3;
  	
//  	*D /= *B;
//  	*R /= *B;
//  	*C /= *B;
//  	*B = 1.0;
}

int whichSide(Vertex* v, double d, double r, double c, Vertex* norm) {
	Vertex* temp = new Vertex(d-v->p1,r-v->p2,c-v->p3);
	double result = norm->dotProduct(temp);
	if (result == 0)
		return 0;
	else if (result < 0)
		return -1;
	else
		return 1;
}

bool correctSide(Vertex* v1, Vertex* v2, Vertex* v3,
			  double* D, double* R, double* C,
			  double d, double r, double c) {
  	Vertex* vt = new Vertex(*v1,*D,*R,*C);
  	double Dt,Rt,Ct,Bt;
  	calcPlane(&Dt,&Rt,&Ct,&Bt,v1,v2,vt);
	Vertex* norm = new Vertex(Dt,Rt,Ct);
  	
  	int result = whichSide(vt,d,r,c,norm);
  	if (result == 0)
  		return true;
  	for (int i = 0; i <= 1; i++) {
		for (int j = 0; j <= 1; j++) {
			for (int k = 0; k <= 1; k++) {
			  	if (result == whichSide(vt,v3->p1+i,v3->p2+j,v3->p3+k,norm))
			  		return true;
	  		}
  		}
	}
  	
	return false;
	
}

bool planeThroughCube(Vertex* vr, double *D, double* R, double* C, double d, double r, double c) {	
	int prev = -100;
	int result = -100;
	Vertex* norm = new Vertex(*D,*R,*C);
	for (int i = 0; i <= 1; i++) {
		for (int j = 0; j <= 1; j++) {
			for (int k = 0; k <= 1; k++) {
				result = whichSide(vr,d+i,r+j,c+k,norm);
				if (i == 0 && j == 0 && k == 0)
					prev = result;
				else if (result == 0 || result != prev)
					return true;
			}
		}
	}
	return false;
}

bool isIn(double* D, double* R, double* C, double* B, Triangle* t, int d, int r, int c) {
//	double offset = 0.000001;
//	double plane_calc = *D * d + *R * r + *C * c;
//	if (plane_calc <= (*B + offset) && plane_calc >= (*B - offset)) {
	if (planeThroughCube(&t->v1,D,R,C,d,r,c)) {
		Vertex* v1 = &t->v1;
		Vertex* v2 = &t->v2;
		Vertex* v3 = &t->v3;
		if (correctSide(v1,v2,v3,D,R,C,d,r,c) && correctSide(v2,v3,v1,D,R,C,d,r,c) && correctSide(v3,v1,v2,D,R,C,d,r,c))
			return true;
	}
	return false;
}

int tripleMin(double x, double y, double z) {
	return (int)min(min(x,y),min(y,z));
}

int tripleMax(double x, double y, double z) {
	return (int)max(max(x,y),max(y,z));
}

void fillTriangle(int* s_red, int* s_green, int* s_blue, Triangle* t, int* res) {
	double D,R,C,B;
	calcPlane(&D,&R,&C,&B,
			&t->v1,&t->v2,&t->v3);
	
	Vertex* v1 = &t->v1;
	Vertex* v2 = &t->v2;
	Vertex* v3 = &t->v3;
	
	//Bounding Box
	int mind = tripleMin(v1->p1,v2->p1,v3->p1);
	int maxd = tripleMax(v1->p1,v2->p1,v3->p1);
	int minr = tripleMin(v1->p2,v2->p2,v3->p2);
	int maxr = tripleMax(v1->p2,v2->p2,v3->p2);
	int minc = tripleMin(v1->p3,v2->p3,v3->p3);
	int maxc = tripleMax(v1->p3,v2->p3,v3->p3);
	
	for (int d = mind; d <= maxd; d++) {
		for (int r = minr; r <= maxr; r++) {
			for (int c = minc; c <= maxc; c++) {
				if (isIn(&D,&R,&C,&B,t,d,r,c)) {
					int index = d * res[1] * res[2] + r * res[2] + c;
					s_red[index] = t->color[0];
					s_green[index] = t->color[1];
					s_blue[index] = t->color[2];
				}
			}
		}
	}
}

double render(vector<Triangle>* triangles, int* resolution, int* s_red, int* s_green, int* s_blue) {
	clock_t begin = clock();
	//TODO: INITIALIZE RENDERING
	clock_t end = clock();
     double init_spent = (double)(end - begin) / CLOCKS_PER_SEC;
     
     for (int i = 0; i < triangles->size(); i++) {
     	Triangle* t = &triangles->at(i);     	
     	fillTriangle(s_red,s_green,s_blue,t,resolution);
     }
          
     int count = 0;
     for (int i = 0; i < resolution[0]; i++) {
     	for (int j = 0; j < resolution[1]; j++) {
     		for (int k = 0; k < resolution[2]; k++) {
     			cout << " (" << s_red[count] << ',' << s_green[count] << ',' << s_blue[count] << ')';
     			count++;
     		}
     		cout << endl;
     	}
     	cout << endl;
     }
     
	return init_spent;
}
